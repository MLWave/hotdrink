/**
 * @fileOverview <p>{@link hotdrink.Model}</p>
 * @author John Freeman
 */

//provides("hotdrink.Model");

//requires("hotdrink.graph.CGraph");
//requires("hotdrink.graph.SGraph");
//requires("hotdrink.graph.EGraph");

(function () {

  /* TODO: Handle the other cell types. */
  var cellTypeSwitch = {
    /* Have to wrap property names in quotes because "interface" is an invalid
     * name? */
    "interface" : "interfaces",
    "output" : "outputs",
    "invariant" : "invariants"
  };

  var Model = Class.create(
  /** @lends hotdrink.Model# */
  {
    /**
     * @param {Object:CGraphAst} cgraph Forwarded to {@link hotdrink.graph.CGraph}.
     * @see hotdrink.graph.CGraph For documentation on the CGraphAst type.
     *
     * @param {Object:MethodRegistry} methodRegistry
     *   Forwarded to {@link hotdrink.graph.EGraph}.
     * @see hotdrink.graph.EGraph For documentation on the MethodRegistry type.
     *
     * @param {Object} [inputs={}]
     *   Initial values for input variables.
     *
     * @constructs
     * @class
     *   <p>
     *   The model manages the constraint system, priority, values, and
     *   plugged-in behaviors.  It provides a limited interface to the
     *   underlying system for two different clients: behaviors and views.
     *   </p>
     *
     *   <p>
     *   Behaviors need access to all information in the three fundamental graphs
     *   (constraint, solution, evaluation), and possibly in other behaviors.
     *   Views need access to information on (hopefully) just the variables in the
     *   three graphs and other behaviors.
     *   </p>
     *
     *   <p>
     *   There are workarounds for implementing access control in JavaScript, but
     *   as the project is young, we will not expend that effort on a policy that
     *   is subject to change as more requirements are discovered. For now, access
     *   control will simply be documented.
     *   </p>
     * @property {CGraph} cgraph Constraint graph.
     * @property {SGraph} sgraph Solution graph.
     * @property {EGraph} egraph Evaluation graph.
     * @property {Hash} behaviors Set of registered behaviors, indexed by name.
     * @property {String[]} variables List of all variables.
     * @property {String[]} interfaces List of interface variables.
     * @property {String[]} outputs List of output variables.
     * @property {String[]} invariants List of invariant variables.
     */
    initialize : function (cgraph, methodRegistry, inputs) {
      var model = this;

      this.cgraph = new hotdrink.graph.CGraph(cgraph);
      $H(inputs).each(function (pair) {
        var cv = model.cgraph.variables.get(pair.key);
        ASSERT(cv.cell_type === "input",
          "pass initializers only for input variables");
        cv.initializer = Object.toJSON(pair.value);
      });
      this.sgraph = new hotdrink.graph.SGraph(this.cgraph);
      this.egraph = new hotdrink.graph.EGraph(this.cgraph, methodRegistry);
      this.priority = this.cgraph.variables.keys();

      this.interfaces = [];
      this.outputs = [];
      this.invariants = [];
      this.variables = this.cgraph.variables.keys();

      this.cgraph.variables.each(function (pair) {
        var cellTypeSet = cellTypeSwitch[pair.value.cell_type];
        if (cellTypeSet) {
          model[cellTypeSet].push(pair.key);
        }
      });

      LOG("initial valuation = " + this.egraph.values);

      /* If user edited a new value, then must solve and evaluate.
       * If edited same value, can just re-evaluate. */
      this.needsSolution = true;
      /* Can set multiple values before re-evaluating, so need to keep track of
       * all changes. */
      this.changeSet = this.variables.clone();

      this.behaviors = $H();
      this.registerBehavior("enablement", hotdrink.behavior.Enablement);
    },
    /**
     * Adds a behavior to the model, implementing some functionality, e.g.
     * {@link hotdrink.behavior.Enablement}.
     * 
     * @param {String} name
     *   A name by which clients can refer to the information generated by this
     *   behavior.
     * @param {Behavior} Behavior
     *   A class that models the Behavior concept.
     */
    registerBehavior : function (name, Behavior) {
      this.behaviors.set(name, new Behavior(this));
    },
    /**
     * Set the value of a variable.
     * @param {String} variable
     * @param {concept.Value} value
     */
    set : function (v, value) {
      var ev = this.egraph.variables.get(v);
      ev.hasBeenEdited = true;
      if (value !== ev.value) {
        ev.value = value;
        this.touch(v);
      } else {
        LOG("Ignoring identity assignment.");
      }
    },
    /**
     * Get the value of a variable.
     * @param {String} variable
     * @returns {concept.Value}
     */
    get : function (v) {
      /* TODO: return VariableProxy. */
      return this.egraph.variables.get(v).value;
    },
    /**
     * <p>
     * Possibly solve and evaluate the model, then update all registered behaviors.
     * </p>
     *
     * <p>
     * To allow several variables to be set without triggering an update, this
     * function must be called separately.
     * </p>
     *
     * @returns {String[]}
     *   List of change events including those returned from
     *   {@link hotdrink.graph.EGraph#update} and registered
     *   {@link concept.model.Behavior}s.
     * @see concept.model.Behavior#update
     */
    update : function () {

      var events = [];

      if (this.needsSolution) {

        LOG("Solving...");
        this.sgraph.update(this.cgraph, this.priority);
        this.needsSolution = false;
        LOG("Finished solution.");

      } else {
        LOG("Reusing last solution.");
      }

      /* If needs evaluation... */
      if (this.changeSet.length > 0) {

        /* Evaluate. */
        LOG("Evaluating...");
        LOG("starting valuation = " + this.egraph.values);
        events = this.egraph.update(this.cgraph, this.sgraph, this.changeSet);
        this.changeSet.clear();
        LOG("ending valuation = " + this.egraph.values);
        LOG("Finished evaluation.");

        /* Post-evaluate. */
        var model = this;
        this.behaviors.each(function (pair) {
          LOG("Starting analysis for " + pair.key + " behavior...");
          events = events.concat(pair.value.update(model));
          LOG("Finished analysis for " + pair.key + " behavior.");
        });
      }

      return events;
    },
    /* WARNING: Private functions below. */
    /**
     * Mark a variable as changed and promote its priority.
     * @param {String} v Variable name.
     * @private
     */
    touch : function (v) {
      this.changeSet.push(v);
      if (v !== this.priority[0]) {
        this.priority.splice(this.priority.indexOf(v), 1);
        this.priority.unshift(v);
        this.needsSolution = true;
      }
    }
  });

  var ns = namespace.open("hotdrink");
  ns.Model = Model;

}());

